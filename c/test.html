
<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="referrer" content="origin" />
<title>C++中的也能使用正则表达式 - 我是一只C++小小鸟 - 博客园</title>
<meta property="og:description" content="正则表达式Regex(regular expression)是一种强大的描述字符序列的工具。在许多语言中都存在着正则表达式，C++11中也将正则表达式纳入了新标准的一部分，不仅如此，它还支持了6种不同" />
<link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=9MND-58mJHM3WYMrVHOOLi_G9A3E97Ms0IoclKzpnRk1"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="/skins/darkgreentrip/bundle-darkgreentrip.css?v=EjExWsdi8Ql8RA7Wdq4_YaeuMVhIAL6d2BSGbilapWY1"/>
<link type="text/css" rel="stylesheet" href="/blog/customcss/204173.css?v=Q2%2fZnXNvzrhX4WS%2bQffnFh6qx3A%3d"/>
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/darkgreentrip/bundle-darkgreentrip-mobile.css?v=6NcJHqsIyaE4w19VtgFvCFahrnr2rYCTRRTdxlMDhhQ1"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/ittinybird/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/ittinybird/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/ittinybird/wlwmanifest.xml"/>
<script src="//common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
<script type="text/javascript">var currentBlogApp = 'ittinybird', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="/bundles/blog-common.js?v=93E4BY8zFdnh3jDab2GTlgLeDcUJN7mm8kJmYz6dndo1" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>
<!--PageBeginHtml Block Begin-->
<link type="text/css" rel="stylesheet" href="https://files.cnblogs.com/files/ittinybird/mystyle.css">
 
  
<!--PageBeginHtml Block End-->

<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="https://www.cnblogs.com/ittinybird/"><img id="blogLogo" src="/Skins/custom/images/logo.gif" alt="返回主页" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/ittinybird/">我是一只C++小小鸟</a></h1>
<h2>What hurts more,the pain of hardwork or the pain of regret?</h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">博客园</a></li>
<li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/ittinybird/">首页</a></li>
<li><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
<li><a id="blog_nav_contact" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/%E6%88%91%E6%98%AF%E4%B8%80%E5%8F%AAC%2B%2B%E5%B0%8F%E5%B0%8F%E9%B8%9F">联系</a></li>
<li><a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/ittinybird/rss">订阅</a>
<!--<a id="blog_nav_rss_image" class="aHeaderXML" href="https://www.cnblogs.com/ittinybird/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a>--></li>
<li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>
		<div class="blogStats">
			
			<div id="blog_stats">
<span id="stats_post_count">随笔 - 57&nbsp; </span>
<span id="stats_article_count">文章 - 0&nbsp; </span>
<span id="stats-comment_count">评论 - 79</span>
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
<div id="post_detail">
<!--done-->
<div id="topics">
	<div class = "post">
		<h1 class = "postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/ittinybird/p/4853532.html">C++中的也能使用正则表达式</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body"><p>&nbsp; &nbsp; &nbsp; 正则表达式Regex(regular expression)是一种强大的描述字符序列的工具。在许多语言中都存在着正则表达式，C++11中也将正则表达式纳入了新标准的一部分，不仅如此，它还支持了6种不同的正则表达式的语法，分别是：ECMASCRIPT、basic、extended、awk、grep和egrep。其中ECMASCRIPT是默认的语法，具体使用哪种语法我们可以在构造正则表达式的时候指定。</p>
<blockquote>
<p>注：ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。它往往被称为JavaScript，但实际上后者是ECMA-262标准的实现和扩展。</p>
</blockquote>
<p>下面我们就以本篇博客的页面（<span style="color: #0000ff;"><a href="http://www.cnblogs.com/ittinybird/p/4853532.html" target="_blank"><span style="color: #0000ff;">http://www.cnblogs.com/ittinybird/p/4853532.html</span></a></span>）源码为例，从零开始演示如何在C++中使用正则表达式提取一个网页源码中所有可用的http链接。如果有时间的话，近期我想用C++11的新特性，改写一下以前的C++爬虫程序，分享出来。</p>
<div class="tip">确保你的编译器支持Regex</div>
<p>&nbsp; &nbsp; &nbsp;如果你的编译器是GCC-4.9.0或者VS2013以下版本，请升级后，再使用。<strong>我之前使用的C++编译器，是GCC 4.8.3，有regex头文件，但是GCC很不厚道的没有实现，语法完全支持，但是库还没跟上，所以编译的时候是没有问题的，但是一运行就会直接抛出异常，非常完美的一个坑有木有！具体错误如下：</strong></p>
<div class="cnblogs_Highlighter">
<pre class="brush:bash;gutter:false;">terminate called after throwing an instance of 'std::regex_error'
  what():  regex_error
Aborted (core dumped)</pre>
</div>
<p>如果你也遇到了这个问题，请不要先怀疑自己，GCC这一点是非常坑爹的！！！我在这个上面浪费了半天的时间才找了出来。所以在尝鲜C++的正则表达式之前，请升级你的编译器，确保你的编译器支持它。</p>
<div class="tip">regex库概览</div>
<p>&nbsp; &nbsp; &nbsp; 在头文件&lt;regex&gt;中包含了多个我们使用正则表达式时需要用到的组件，大致有：</p>
<table style="margin-left: auto; margin-right: auto;" border="0">
<tbody>
<tr>
<td>basic_regex</td>
<td>正则表达式对象,是一个通用的模板，有typedef&nbsp;basic_regex&lt;char&gt; regex 和 typedef basic_regex&lt;char_t&gt;wregex；</td>
</tr>
<tr>
<td>regex_match</td>
<td>将一个字符序列和正则表达式匹配</td>
</tr>
<tr>
<td>regex_search</td>
<td>寻找字符序列中的子串中与正则表达式匹配的结果,<strong>在找到第一个匹配的结果后就会停止查找</strong></td>
</tr>
<tr>
<td>regex_replace</td>
<td>使用格式化的替换文本，替换正则表达式匹配到字符序列的地方</td>
</tr>
<tr>
<td>regex_iterator</td>
<td>迭代器，用来匹配所有 的子串&nbsp;</td>
</tr>
<tr>
<td>match_results</td>
<td>容器类，保存正则表达式匹配的结果。</td>
</tr>
<tr>
<td>sub_match</td>
<td>容器类，保存子正则表达式匹配的字符序列.</td>
</tr>
</tbody>
</table>
<p><span style="line-height: 1.5;">ECMASCRIPT正则表达式语法</span></p>
<p>&nbsp; &nbsp; &nbsp; 正则表达式式的语法基本大同小异，在这里就浪费篇幅细抠了。ECMASCRIPT正则表达式的语法知识可以参考<span style="color: #0000ff;"><a href="http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp" target="_blank"><span style="color: #0000ff;">W3CSCHOOL</span></a></span>。</p>
<div class="tip">构造正则表达式</div>
<p>&nbsp; &nbsp; &nbsp;构造正则表达式用到一个类：basic_regex。basic_regex是一个正则表达式的通用类模板，对char和wchar_t类型都有对应的特化：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:cpp;gutter:false;">typedef basic_regex&lt;char&gt;    regex;
typedef basic_regex&lt;wchar_t&gt; wregex;
</pre>
</div>
<p>构造函数比较多，但是非常简单：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:cpp;gutter:true;">//默认构造函数，将匹配任何的字符序列
basic_regex();
//用一个以&lsquo;\0&rsquo;结束的字符串s构造一个正则表达式
explicit basic_regex( const CharT* s,flag_type f =std::regex_constants::ECMAScript );
//同上，但是制定了用于构造的字符串s的长度为count
basic_regex( const CharT* s, std::size_t count,flag_type f = std::regex_constants::ECMAScript );
//拷贝构造，不赘述
basic_regex( const basic_regex&amp; other );
 //移动构造函数
basic_regex( basic_regex&amp;&amp; other );
//以basic_string类型的str构造正则表达式
template&lt; class ST, class SA &gt;
explicit basic_regex( const std::basic_string&lt;CharT,ST,SA&gt;&amp; str, flag_type f = std::regex_constants::ECMAScript );
//指定范围[first,last)内的字符串构造正则表达式
template&lt; class ForwardIt &gt;
basic_regex( ForwardIt first, ForwardIt last, flag_type f = std::regex_constants::ECMAScript );
//使用initializer_list构造
basic_regex( std::initializer_list&lt;CharT&gt; init, flag_type f = std::regex_constants::ECMAScript );
</pre>
</div>
<p>以上除默认构造之外的构造函数，都有一个flag_type类型的参数用于指定正则表达式的语法，ECMASCRIPT、basic、extended、awk、grep和egrep均是可选的值。除此之外还有其他几种可能的的标志，用于改变正则表达式匹配时的规则和行为：</p>
<table style="margin-left: auto; margin-right: auto;" border="0">
<tbody>
<tr>
<td>flag_type</td>
<td>effects</td>
</tr>
<tr>
<td>icase</td>
<td>在匹配过程中忽略大小写</td>
</tr>
<tr>
<td>nosubs</td>
<td>不保存匹配的子表达式</td>
</tr>
<tr>
<td>optimize</td>
<td>执行速度优于构造速度</td>
</tr>
</tbody>
</table>
<p><span style="line-height: 1.5;">&nbsp; &nbsp; &nbsp; 有了构造函数之后，现在我们就可以先构造出一个提取http链接的正则表达式：</span></p>
<div class="cnblogs_Highlighter">
<pre class="brush:cpp;gutter:true;">std::string pattern("http(s)?://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)?");    //匹配规则很简单，如果有疑惑，可以对照语法查看
std::regex r(pattern);
</pre>
</div>
<p><strong>值得一提的是在C++中'\'这个字符需要转义，因此所有ECMASCRIPT正则表达式语法中的'\'都需要写成&ldquo;\\&rdquo;的形式</strong>。我测试的时候，这段regex如果没有加转义，在gcc中会给出警告提示，vs2013编译后后运行直接崩溃了。</p>
<div class="tip">正确地处理输入</div>
<p>&nbsp; &nbsp; &nbsp; 先扯一个题外话，假设我们不是使用了网络库自动在程序中下载的网页，在我们手动下载了网页并保存到文件后，首先我们要做的还是先把网页的内容(html源码)存入一个std::string中，我们可能会使用这样的错误方式：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:cpp;gutter:true;">int main()
{
    std::string tmp,html;
    while(std::cin &gt;&gt; tmp)
        html += tmp;
}
</pre>
</div>
<p>这样一来源代码中所有的空白字符就无意中被我们全处理了，这显然不合适。这里我们还是使用getline()这个函数来处理：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:cpp;gutter:true;">int main()
{
    std::string tmp,html;
    while(getline(std::cin,tmp))
    {
        html += tmp;
        html += '\n';
    }
}
</pre>
</div>
<p>这样一来原来的文本才能得到正确的输入。当然<strong>个人以为这些小细节还是值得注意的，到时候出错debug的时候，我想我们更多地怀疑的是自己的正则表达式是否是有效</strong>。</p>
<div class="tip">regex_search()只查找到第一个匹配的子序列</div>
<p>&nbsp; &nbsp; &nbsp; 根据函数的字面语义，我们可能会错误的选择regex_search()这个函数来进行匹配。其函数原型也有6个重载的<span style="color: #0000ff;"><a href="http://en.cppreference.com/w/cpp/regex/regex_search" target="_blank"><span style="color: #0000ff;">版本</span></a></span>，用法也是大同小异，<strong>函数返回值是bool值</strong>，成功返回true，失败返回false。鉴于篇幅，我们只看我们下面要使用的这个：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:cpp;gutter:true;">template&lt; class STraits, class SAlloc,class Alloc, class CharT, class Traits &gt;
bool regex_search( const std::basic_string&lt;CharT,STraits,SAlloc&gt;&amp; s,
                   std::match_results&lt;typename std::basic_string&lt;CharT,STraits,SAlloc&gt;::const_iterator, Alloc&gt;&amp; m,
                   const std::basic_regex&lt;CharT, Traits&gt;&amp; e,
                   std::regex_constants::match_flag_type flags = std::regex_constants::match_default );
</pre>
</div>
<p>第一个参数s是std::basic_string类型的，它是我们待匹配的字符序列，参数m是一个match_results的容器用于存放匹配到的结果，参数e则是用来存放我们之前构造的正则表达式对象。flags参数值得一提，它的类型是std::regex_constants::match_flag_type，语义上匹配标志的意思。正如在构造正则表达式对象时我们可以指定选项如何处理正则表达式一样，在匹配的过程中我们依然可以指定另外的标志来控制匹配的规则。这些标志的具体含义，我从<a href="http://en.cppreference.com/w/cpp/regex/match_flag_type" target="_blank">cppreference.com</a><span style="color: #0000ff;"> <span style="color: #000000;">引用过来</span></span><span style="color: #000000;">，用的时候查一下就可以了</span><span style="color: #0000ff;">：</span></p>
<table class="t-dsc-begin" style="margin-left: auto; margin-right: auto;">
<tbody>
<tr class="t-dsc-hitem">
<td>Constant</td>
<td>Explanation</td>
</tr>
<tr class="t-dsc">
<td><code>match_not_bol</code></td>
<td>The first character in&nbsp;<em>[first,last)</em>&nbsp;will be treated as if it is&nbsp;<strong>not</strong>&nbsp;at the beginning of a line (i.e.&nbsp;<em>^</em>&nbsp;will not match&nbsp;<em>[first,first)</em></td>
</tr>
<tr class="t-dsc">
<td><code>match_not_eol</code></td>
<td>The last character in&nbsp;<em>[first,last)</em>&nbsp;will be treated as if it is&nbsp;<strong>not</strong>&nbsp;at the end of a line (i.e.&nbsp;<em>$</em>&nbsp;will not match<em>[last,last)</em></td>
</tr>
<tr class="t-dsc">
<td><code>match_not_bow</code></td>
<td><em>"\b"</em>&nbsp;will not match&nbsp;<em>[first,first)</em></td>
</tr>
<tr class="t-dsc">
<td><code>match_not_eow</code></td>
<td><em>"\b"</em>&nbsp;will not match&nbsp;<em>[last,last)</em></td>
</tr>
<tr class="t-dsc">
<td><code>match_any</code></td>
<td>If more than one match is possible, then any match is an acceptable result</td>
</tr>
<tr class="t-dsc">
<td><code>match_not_null</code></td>
<td>Do not match empty sequences</td>
</tr>
<tr class="t-dsc">
<td><code>match_continuous</code></td>
<td>Only match a sub-sequence that begins at&nbsp;<em>first</em></td>
</tr>
<tr class="t-dsc">
<td><code>match_prev_avail</code></td>
<td><em>--first</em>&nbsp;is a valid iterator position. When set, causes&nbsp;<em>match_not_bol</em>&nbsp;and&nbsp;<em>match_not_bow</em>&nbsp;to be ignored</td>
</tr>
<tr class="t-dsc">
<td><code>format_default</code></td>
<td>Use ECMAScript rules to construct strings in&nbsp;<span class="t-lc"><a title="cpp/regex/regex replace" href="http://en.cppreference.com/w/cpp/regex/regex_replace">std::regex_replace</a>&nbsp;(<a class="external text" href="http://ecma-international.org/ecma-262/5.1/#sec-15.5.4.11" rel="nofollow">syntax documentation</a>)</span></td>
</tr>
<tr class="t-dsc">
<td><code>format_sed</code></td>
<td>Use POSIX&nbsp;<em>sed</em>&nbsp;utility rules in&nbsp;<span class="t-lc"><a title="cpp/regex/regex replace" href="http://en.cppreference.com/w/cpp/regex/regex_replace">std::regex_replace</a>. (<a class="external text" href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sed.html#tag_20_116_13_03" rel="nofollow">syntax documentation</a>)</span></td>
</tr>
<tr class="t-dsc">
<td><code>format_no_copy</code></td>
<td>Do not copy un-matched strings to the output in&nbsp;<span class="t-lc"><a title="cpp/regex/regex replace" href="http://en.cppreference.com/w/cpp/regex/regex_replace">std::regex_replace</a></span></td>
</tr>
</tbody>
</table>
<p>根据参数类型，于是我们构造了这样的调用：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:cpp;gutter:true;">std::smatch results;<br />regex_search(html,results,r);
</pre>
</div>
<p>不过，<strong>标准库规定regex_search()在查找到第一个匹配的子串后，就会停止查找</strong>！在本程序中，results参数只带回了第一个满足条件的http链接。这显然并不能满足我们要提取网页中所有HTTP链接需要。</p>
<div class="tip">使用regex_iterator匹配所有子串</div>
<p>&nbsp; &nbsp; &nbsp; 严格意义上regex_iterator是一种迭代器适配器，它用来绑定要匹配的字符序列和regex对象。<strong>regex_iterator的默认构造函数比较特殊，就直接构造了一个尾后迭代器</strong>。另外一个构造函数原型：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:cpp;gutter:true;">regex_iterator(BidirIt a, BidirIt b,                                                           //分别是待匹配字符序列的首迭代器和尾后迭代器
               const regex_type&amp; re,                                                           //regex对象
               std::regex_constants::match_flag_type m = std::regex_constants::match_default); //标志，同上面的regex_search()中的</pre>
</div>
<p>和上边的regex_search()一样，regex_iterator的构造函数中也有std::regex_constants::match_flag_type类型的参数，用法一样。其实regex_iterator的内部实现就是调用了regex_search()，这个参数是用来传递给regex_search()的。用gif或许可以演示的比较形象一点，具体是这样工作的（颜色加深部分，表示可以匹配的子序列）：</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://images2015.cnblogs.com/blog/637814/201510/637814-20151005003011386-295552165.gif" alt="" /></p>
<p>首先在构造regex_iterator的时候，构造函数中首先就调用一次regex_search()将迭代器it指向了第一个匹配的子序列。以后的每一次迭代的过程中（++it），都会在以后剩下的子序列中继续调用regex_search()，直到迭代器走到最后。it就一直&ldquo;指向&rdquo;了匹配的子序列。</p>
<p>&nbsp; &nbsp; &nbsp; 知道了原理，我们写起来代码就轻松多了。结合前面的部分我们，这个程序就基本写好了：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:cpp;gutter:true;">#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

int main()
{
    std::string tmp,html;
    while(getline(std::cin,tmp))
    {
        tmp += '\n';
        html += tmp;
    }
	std::string pattern("http(s)?://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)?");
	pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]]*";
	std::regex r(pattern);
	for (std::sregex_iterator it(html.begin(), html.end(), r), end;     //end是尾后迭代器，regex_iterator是regex_iterator的string类型的版本
		it != end;
		++it)
	{
		std::cout &lt;&lt; it-&gt;str() &lt;&lt; std::endl;
	}
}
</pre>
</div>
<p>下载本页的html源码保存为test.html，编译这个源码测试一下，大功告成：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:bash;gutter:false;">[regex]g++ regex.cpp  -std=c++11 -omain
[regex]main &lt; test.html
http://www.cnblogs.com/ittinybird/rss
http://www.cnblogs.com/ittinybird/rsd.xml
http://www.cnblogs.com/ittinybird/wlwmanifest.xml
http://common.cnblogs.com/script/jquery.js
http://files.cnblogs.com/files/ittinybird/mystyle.css
http://www.cnblogs.com/ittinybird/
http://www.cnblogs.com/ittinybird/
http://www.cnblogs.com/ittinybird/
http://i.cnblogs.com/EditPosts.aspx?opt=1
http://msg.cnblogs.com/send/%E6%88%91%E6%98%AF%E4%B8%80%E5%8F%AAC%2B%2B%E5%B0%8F%E5%B0%8F%E9%B8%9F
http://www.cnblogs.com/ittinybird/rss
http://www.cnblogs.com/ittinybird/rss
http://www.cnblogs.com/images/xml.gif
http://i.cnblogs.com/
http://www.cnblogs.com/ittinybird/p/4853532.html
http://www.cnblogs.com/ittinybird/p/4853532.html
http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp
http://www.cnblogs.com/ittinybird/
http://i.cnblogs.com/EditPosts.aspx?postid=4853532
http://www.cnblogs.com/
http://q.cnblogs.com/
http://news.cnblogs.com/
http://home.cnblogs.com/ing/
http://job.cnblogs.com/
http://kb.cnblogs.com/
</pre>
</div>
<div class="tip">regex和异常处理</div>
<p>&nbsp; &nbsp; &nbsp; 如果我们的正则表达式存在错误，则在运行的时候标准库会抛出一个regex_error异常，他有一个名为code的成员，用于标记错误的类型，具体错误值和语义如下表所示：</p>
<table style="margin-left: auto; margin-right: auto;" border="0">
<tbody>
<tr>
<td>code</td>
<td>含义</td>
</tr>
<tr>
<td>error_collate</td>
<td>无效的元素校对</td>
</tr>
<tr>
<td>error_ctype</td>
<td>无效的字符类</td>
</tr>
<tr>
<td>error_escape</td>
<td>无效的转移字符或者无效的尾置转义</td>
</tr>
<tr>
<td>error_backref</td>
<td>无效的向后引用</td>
</tr>
<tr>
<td>error_brack</td>
<td>方括号不匹配</td>
</tr>
<tr>
<td>error_paren</td>
<td>小括号不匹配</td>
</tr>
<tr>
<td>error_brace</td>
<td>大括号不匹配</td>
</tr>
<tr>
<td>error_badbrace</td>
<td>大括号中的范围无效</td>
</tr>
<tr>
<td>error_range</td>
<td>无效的（不合法）字符范围</td>
</tr>
<tr>
<td>error_space</td>
<td>内存不足</td>
</tr>
<tr>
<td>error_badrepeat</td>
<td>重复字符之前没有正则表达式（* + ?）</td>
</tr>
<tr>
<td>error_complexity</td>
<td>太复杂了，标准库君hold不住了</td>
</tr>
<tr>
<td>error_stack</td>
<td>栈空间不足了</td>
</tr>
</tbody>
</table>
<p>有关异常处理的基本内容，不是本篇要讨论的内容，就不赘述了。</p>
<div class="tip">小结</div>
<p>&nbsp; &nbsp; &nbsp;C++11标准库中的正则表达式部分还有部分内容本文没有涉及，个人以为掌握了以上的内容后，基本上看一看<span style="color: #0000ff;"><a href="http://en.cppreference.com/w/cpp/regex" target="_blank"><span style="color: #0000ff;">接口</span></a></span>就知道怎么使用了，这里就不浪费篇幅了。</p>
<p>&nbsp; &nbsp; &nbsp;谢谢你的阅读，错误之处还请您指正，我将万分感谢：）。</p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>


		</div>
		<div class = "postDesc">posted @ <span id="post-date">2015-10-05 01:34</span> <a href='https://www.cnblogs.com/ittinybird/'>我是一只C++小小鸟</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href ="https://i.cnblogs.com/EditPosts.aspx?postid=4853532" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4853532);return false;">收藏</a></div>
	</div>
	<script type="text/javascript">var allowComments=true,cb_blogId=204173,cb_entryId=4853532,cb_blogApp=currentBlogApp,cb_blogUserGuid='a192843a-7de5-e311-8d02-90b11c0b17d6',cb_entryCreatedDate='2015/10/5 1:34:00';loadViewCount(cb_entryId);var cb_postType=1;</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id='comment_form' class='commentform'>
<a name='commentform'></a>
<div id='divCommentShow'></div>
<div id='comment_nav'><span id='span_refresh_tips'></span><a href='javascript:void(0);' onclick='return RefreshCommentList();' id='lnk_RefreshComments' runat='server' clientidmode='Static'>刷新评论</a><a href='#' onclick='return RefreshPage();'>刷新页面</a><a href='#top'>返回顶部</a></div>
<div id='comment_form_container'></div>
<div class='ad_text_commentbox' id='ad_text_under_commentbox'></div>
<div id='ad_t2'></div>
<div id='opt_under_post'></div>
<div id='cnblogs_c1' class='c_ad_block'></div>
<div id='under_post_news'></div>
<script async='async' src='https://www.googletagservices.com/tag/js/gpt.js'></script>
<script>
  var googletag = googletag || {};
  googletag.cmd = googletag.cmd || [];
</script>

<script>
  googletag.cmd.push(function() {
    googletag.defineSlot('/1090369/C2', [468, 60], 'div-gpt-ad-1539008685004-0').addService(googletag.pubads());
    googletag.pubads().enableSingleRequest();
    googletag.enableServices();
  });
</script>
<div id='cnblogs_c2' class='c_ad_block'>
    <div id='div-gpt-ad-1539008685004-0' style='height:60px; width:468px;'>
    <script>
    if (new Date() >= new Date(2018, 9, 13)) {
        googletag.cmd.push(function() { googletag.display('div-gpt-ad-1539008685004-0'); });
    }
    </script>
    </div>
</div>
<div id='under_post_kb'></div>
<div id='HistoryToday' class='c_ad_block'></div>
<script type='text/javascript'>
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);   
</script>
</div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright &copy;2018 我是一只C++小小鸟
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->
</body>
</html>
